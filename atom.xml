<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://QLZL.github.io</id>
    <title>Gridea</title>
    <updated>2021-02-04T01:40:21.946Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://QLZL.github.io"/>
    <link rel="self" href="https://QLZL.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://QLZL.github.io/images/avatar.png</logo>
    <icon>https://QLZL.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[ CentOS 7 添加用户及设置权限]]></title>
        <id>https://QLZL.github.io/post/centos-7-tian-jia-yong-hu-ji-she-zhi-quan-xian/</id>
        <link href="https://QLZL.github.io/post/centos-7-tian-jia-yong-hu-ji-she-zhi-quan-xian/">
        </link>
        <updated>2021-01-06T09:11:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-添加用户">一、添加用户</h2>
<h3 id="1-登录root用户">1、登录root用户</h3>
<h3 id="2-添加用户">2、添加用户</h3>
<pre><code>[root@qlzl ~]# useradd fenghuan
</code></pre>
<h3 id="3-设置用户密码">3、设置用户密码</h3>
<pre><code>[root@qlzl ~]# passwd fenghuan
Changing password for user fenghuan.
New password: 
BAD PASSWORD: The password contains the user name in some form
Retype new password: 
passwd: all authentication tokens updated successfully.
</code></pre>
<h2 id="二-给用户添加root权限">二、给用户添加root权限</h2>
<h3 id="1-切换到root">1、切换到root</h3>
<h3 id="2-为sudoers-添加可写权限">2、为sudoers 添加可写权限</h3>
<pre><code>[root@qlzl ~]# chmod -v u+w /etc/sudoers
mode of ‘/etc/sudoers’ changed from 0440 (r--r-----) to 0640 (rw-r-----)
</code></pre>
<h3 id="3-编辑">3、编辑</h3>
<pre><code>[root@qlzl ~]# vi /etc/sudoers
</code></pre>
<h3 id="4-添加">4、添加</h3>
<pre><code>## Allow root to tun any commands anywher
   root ALL=(ALL) ALL
   xxx ALL=(ALL) ALL  # xxx为新用户
</code></pre>
<h3 id="5-保存">5、保存</h3>
<h3 id="6-取消sudoers文件可写权限">6、取消sudoers文件可写权限</h3>
<pre><code>[root@qlzl ~]# chmod -v u-w /etc/sudoers
mode of ‘/etc/sudoers’ changed from 0640 (rw-r-----) to 0440 (r--r-----)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis命令启动]]></title>
        <id>https://QLZL.github.io/post/redis-ming-ling-qi-dong/</id>
        <link href="https://QLZL.github.io/post/redis-ming-ling-qi-dong/">
        </link>
        <updated>2020-12-24T01:13:01.000Z</updated>
        <content type="html"><![CDATA[<p>1.进入Redis文件夹</p>
<p>2.cmd命令，redis-server.exe redis.windows.conf。</p>
<p>将Redis加入到Windows服务中：</p>
<p>redis-server.exe --service-install redis.windows.conf --loglevel verbose</p>
<figure data-type="image" tabindex="1"><img src="https://QLZL.github.io/post-images/1608772404032.png" alt="" loading="lazy"></figure>
<p>卸载：</p>
<p>redis-server --service-uninstall</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL语法]]></title>
        <id>https://QLZL.github.io/post/mysql-yu-fa/</id>
        <link href="https://QLZL.github.io/post/mysql-yu-fa/">
        </link>
        <updated>2020-12-24T01:02:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mysql-union-操作符">MySQL UNION 操作符</h2>
<h3 id="描述">描述</h3>
<p>MySQL union 操作符用于连接两个以上的select语句的结果组合到一个结果集合中。多个select语句会删除重复的数据。</p>
<h3 id="语法">语法</h3>
<pre><code class="language-mysql">select expression1, expression2, ..... exprssion_n
from tables
[where conditions]
union [all | distinct]
select expression1, expression2, ..... exprssion_n
from tables
[where conditions]
</code></pre>
<h3 id="参数">参数</h3>
<ul>
<li>expression1, expression2, ..... expression_n : 要检索的列。</li>
<li>tables : 要检索的数据表。</li>
<li>where conditions : 可选，检索条件。</li>
<li>all : 可选，返回所有结果集，包括重复数据。</li>
<li>distinct : 可选，删除结果集中重复的数据。默认情况下union操作符已经删除了重复数据，所以distinct修饰符对结果没啥影响。</li>
</ul>
<h3 id="演示数据库">演示数据库</h3>
<pre><code class="language-mysql">select * from websites;
</code></pre>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>淘宝</td>
<td>CN</td>
</tr>
<tr>
<td>2</td>
<td>Google</td>
<td>USD</td>
</tr>
<tr>
<td>3</td>
<td>stackoverflow</td>
<td>IND</td>
</tr>
<tr>
<td>4</td>
<td>微博</td>
<td>CN</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">select * from app;
</code></pre>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>QQ</td>
<td>CN</td>
</tr>
<tr>
<td>2</td>
<td>淘宝</td>
<td>CN</td>
</tr>
<tr>
<td>3</td>
<td>微博</td>
<td>CN</td>
</tr>
</tbody>
</table>
<h3 id="sql-union-实例">SQL UNION 实例</h3>
<pre><code class="language-mysql">select country from websites
union
select country from app
order by country;
</code></pre>
<table>
<thead>
<tr>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>CN</td>
</tr>
<tr>
<td>IND</td>
</tr>
<tr>
<td>USA</td>
</tr>
</tbody>
</table>
<h3 id="sql-union-all-实例">SQL UNION ALL 实例</h3>
<pre><code class="language-mysql">select country from websites
union all
select country from app
order by country;
</code></pre>
<table>
<thead>
<tr>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>CN</td>
</tr>
<tr>
<td>CN</td>
</tr>
<tr>
<td>CN</td>
</tr>
<tr>
<td>CN</td>
</tr>
<tr>
<td>CN</td>
</tr>
<tr>
<td>IND</td>
</tr>
<tr>
<td>USA</td>
</tr>
</tbody>
</table>
<h3 id="带有-where-的-sql-union-all">带有 WHERE 的 SQL UNION ALL</h3>
<pre><code class="language-mysql">select country, name from websites
where country=&quot;CN&quot;
union all
select country, name from app
where country=&quot;CN&quot;
order by country;
</code></pre>
<table>
<thead>
<tr>
<th>country</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>CN</td>
<td>淘宝</td>
</tr>
<tr>
<td>CN</td>
<td>微博</td>
</tr>
<tr>
<td>CN</td>
<td>QQ app</td>
</tr>
<tr>
<td>CN</td>
<td>淘宝 app</td>
</tr>
<tr>
<td>CN</td>
<td>微博 app</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结</h3>
<p><strong>UNION 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）</p>
<p><strong>UNION ALL 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p>
<h2 id="mysql-排序">MySQL 排序</h2>
<p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。</p>
<p>如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 <strong>ORDER BY</strong> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p>
<h3 id="语法-2">语法</h3>
<p>SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：</p>
<pre><code class="language-mysql">SELECT field1, field2,...fieldN 
FROM table_name1, table_name2...
ORDER BY 
field1 [ASC [DESC][默认 ASC]], 
[field2...] [ASC [DESC][默认 ASC]];
</code></pre>
<ul>
<li>可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li>
<li>可以设定多个字段来排序。</li>
<li>可以使用asc 或 desc 关键字来设置查询结果是按升序或降序排列。默认情况，它是按升序排列。</li>
<li>可以添加where ..... like 子句来设置条件。</li>
</ul>
<h3 id="order-by-实例">ORDER BY 实例</h3>
<pre><code class="language-mysql">select * from websites order by id desc;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th>name</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4</td>
<td>微博</td>
<td>CN</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>stackoverflow</td>
<td>IND</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td>Google</td>
<td>USA</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td>淘宝</td>
<td>CN</td>
</tr>
</tbody>
</table>
<h2 id="mysql-group-by-分组">MySQL GROUP BY 分组</h2>
<p>GROUP BY 语句根据一个或多个列对结果集进行分组。</p>
<p>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p>
<h3 id="group-by-语法">group by 语法</h3>
<pre><code class="language-mysql">SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
</code></pre>
<h3 id="实例演示">实例演示</h3>
<p>本实例使用到了以下表结构及数据，使用前我们可以先将以下数据导入数据库中。</p>
<pre><code class="language-mysql">SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `employee_tbl`
-- ----------------------------
DROP TABLE IF EXISTS `employee_tbl`;
CREATE TABLE `employee_tbl` (
  `id` int(11) NOT NULL,
  `name` char(10) NOT NULL DEFAULT '',
  `date` datetime NOT NULL,
  `singin` tinyint(4) NOT NULL DEFAULT '0' COMMENT '登录次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `employee_tbl`
-- ----------------------------
BEGIN;
INSERT INTO `employee_tbl` 
VALUES ('1', '小明', '2016-04-22 15:25:33', '1'), 
('2', '小王', '2016-04-20 15:25:47', '3'), 
('3', '小丽', '2016-04-19 15:26:02', '2'), 
('4', '小王', '2016-04-07 15:26:14', '4'), 
('5', '小明', '2016-04-11 15:26:40', '4'), 
('6', '小明', '2016-04-04 15:26:54', '2');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
</code></pre>
<p>导入成功后，执行以下 SQL 语句：</p>
<pre><code class="language-mysql">SELECT * FROM employee_tbl;
+----+--------+---------------------+--------+
| id | name   | date                | singin |
+----+--------+---------------------+--------+
|  1 | 小明    | 2016-04-22 15:25:33 |      1 |
|  2 | 小王    | 2016-04-20 15:25:47 |      3 |
|  3 | 小丽    | 2016-04-19 15:26:02 |      2 |
|  4 | 小王    | 2016-04-07 15:26:14 |      4 |
|  5 | 小明    | 2016-04-11 15:26:40 |      4 |
|  6 | 小明    | 2016-04-04 15:26:54 |      2 |
+----+--------+---------------------+--------+
</code></pre>
<p>接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录：</p>
<pre><code class="language-mysql">SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;
+--------+----------+
| name   | COUNT(*) |
+--------+----------+
| 小丽    |        1 |
| 小明    |        3 |
| 小王    |        2 |
+--------+----------+
</code></pre>
<h3 id="使用with-rollup">使用with rollup</h3>
<p>WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</p>
<p>例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数：</p>
<pre><code class="language-mysql">SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
+--------+--------------+
| name   | singin_count |
+--------+--------------+
| 小丽    |            2 |
| 小明    |            7 |
| 小王    |            7 |
| NULL   |           16 |
+--------+--------------+
</code></pre>
<p>其中记录 NULL 表示所有人的登录次数。</p>
<p>我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：</p>
<pre><code class="language-mysql">select coalesce(a,b,c);
</code></pre>
<p>参数说明：如果a<mark>null,则选择b；如果b</mark>null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p>
<p>以下实例中如果名字为空我们使用总数代替：</p>
<pre><code class="language-mysql">SELECT coalesce(name, '总数') as name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
+-----------+--------------+
| name      | singin_count |
+-----------+--------------+
| 小丽       |            2 |
| 小明       |            7 |
| 小王       |            7 |
| 总数       |           16 |
+-----------+--------------+
</code></pre>
<h2 id="mysql-连接的使用">MySQL 连接的使用</h2>
<p>在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</p>
<p>本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。</p>
<p>你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</p>
<p>JOIN 按照功能大致分为如下三类：</p>
<ul>
<li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li>
<li>**LEFT JOIN（左连接）：**获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
<h3 id="演示数据库-2">演示数据库</h3>
<pre><code class="language-mysql">mysql&gt; SELECT * FROM tcount_tbl;
+---------------+--------------+
| runoob_author | runoob_count |
+---------------+--------------+
| 菜鸟教程        | 10           |
| RUNOOB.COM    | 20           |
| Google        | 22           |
+---------------+--------------+
3 rows in set (0.01 sec)
 
mysql&gt; SELECT * from runoob_tbl;
+-----------+---------------+---------------+-----------------+
| runoob_id | runoob_title  | runoob_author | submission_date |
+-----------+---------------+---------------+-----------------+
| 1         | 学习 PHP       | 菜鸟教程        | 2017-04-12      |
| 2         | 学习 MySQL     | 菜鸟教程        | 2017-04-12      |
| 3         | 学习 Java      | RUNOOB.COM    | 2015-05-01      |
| 4         | 学习 Python    | RUNOOB.COM    | 2016-03-06      |
| 5         | 学习 C         | FK            | 2017-04-05      |
+-----------+---------------+---------------+-----------------+
</code></pre>
<h3 id="mysql-inner-join">MySQL inner join</h3>
<p>使用MySQL的**INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)**来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值：</p>
<pre><code class="language-mysql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程          | 10             |
| 2           | 菜鸟教程          | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
+-------------+-----------------+----------------+
</code></pre>
<p>以上SQL语句等价于：</p>
<pre><code class="language-mysql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程          | 10             |
| 2           | 菜鸟教程          | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
+-------------+-----------------+----------------+
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://QLZL.github.io/post-images/1608771882960.gif" alt="" loading="lazy"></figure>
<h3 id="mysql-left-join">MySQL left join</h3>
<p>MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p>
<p>尝试以下实例，以 <strong>runoob_tbl</strong> 为左表，<strong>tcount_tbl</strong> 为右表，理解 MySQL LEFT JOIN 的应用：</p>
<pre><code class="language-mysql">SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程          | 10             |
| 2           | 菜鸟教程          | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
| 5           | FK              | NULL           |
+-------------+-----------------+----------------+
</code></pre>
<p>以上实例中使用了 LEFT JOIN，该语句会读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。</p>
<figure data-type="image" tabindex="2"><img src="https://QLZL.github.io/post-images/1608771905638.gif" alt="" loading="lazy"></figure>
<h3 id="mysql-right-join">MySQL right join</h3>
<p>MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</p>
<p>以 <strong>runoob_tbl</strong> 为左表，<strong>tcount_tbl</strong> 为右表，理解MySQL RIGHT JOIN的应用：</p>
<pre><code class="language-mysql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程          | 10             |
| 2           | 菜鸟教程          | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
| NULL        | NULL            | 22             |
+-------------+-----------------+----------------+
</code></pre>
<p>以上实例中使用了 RIGHT JOIN，该语句会读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。</p>
<figure data-type="image" tabindex="3"><img src="https://QLZL.github.io/post-images/1608771919408.gif" alt="" loading="lazy"></figure>
<h2 id="mysql-null-处理">MySQL NULL 处理</h2>
<p>我们已经知道 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。</p>
<p>为了处理这种情况，MySQL提供了三大运算符:</p>
<ul>
<li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li>
<li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</li>
<li><strong>&lt;=&gt;:</strong> 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。</li>
</ul>
<p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p>
<p>在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 NULL，即 NULL = NULL 返回 NULL 。</p>
<p>MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。</p>
<h3 id="实例">实例</h3>
<p>演示数据库</p>
<pre><code class="language-mysql">mysql&gt; SELECT * from runoob_test_tbl;
+---------------+--------------+
| runoob_author | runoob_count |
+---------------+--------------+
| RUNOOB        | 20           |
| 菜鸟教程        | NULL         |
| Google        | NULL         |
| FK            | 20           |
+---------------+--------------+
</code></pre>
<p>实例中你可以看到 = 和 != 运算符是不起作用的：</p>
<pre><code class="language-mysql">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;
Empty set (0.00 sec)
mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count != NULL;
Empty set (0.01 sec)
</code></pre>
<p>查找数据表中 runoob_test_tbl 列是否为 NULL，必须使用 <strong>IS NULL</strong> 和 <strong>IS NOT NULL</strong>，如下实例：</p>
<pre><code class="language-mysql">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;
+---------------+--------------+
| runoob_author | runoob_count |
+---------------+--------------+
| 菜鸟教程  | NULL         |
| Google        | NULL         |
+---------------+--------------+
2 rows in set (0.01 sec)
 
mysql&gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;
+---------------+--------------+
| runoob_author | runoob_count |
+---------------+--------------+
| RUNOOB        | 20           |
| FK            | 20           |
+---------------+--------------+
2 rows in set (0.01 sec)
</code></pre>
<h2 id="mysql-事务">MySQL 事务</h2>
<p>MySQL事务主要用于处理造作量大，复杂度高的数据。比如，在人员管理系统中，删除一个人员，你既需要删除人员的基本资料，也要删除和该人员的相关的信息，如信箱，文章等等，这样，这些数据库造作语句就构成一个事务。</p>
<ul>
<li>在MySQL中只有使用了innodb数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的SQL语句妖魔全部执行，要么全部不执行。</li>
<li>事务用来管理insert，update，delete语句</li>
</ul>
<p>一般来说，事务必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Lsolation，又称独立性）、持久性（Durability）。</p>
<ul>
<li>**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>**一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>**隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>**持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<blockquote>
<p><em>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</em></p>
</blockquote>
<h3 id="事务控制语句">事务控制语句：</h3>
<ul>
<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>
<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>
<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>
</ul>
<h3 id="mysql-事务处理主要有两种方法">MYSQL 事务处理主要有两种方法：</h3>
<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ul>
<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>
<pre><code class="language-mysql">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表
Query OK, 0 rows affected (0.04 sec)
 
mysql&gt; select * from runoob_transaction_test;
Empty set (0.01 sec)
 
mysql&gt; begin;  # 开始事务
Query OK, 0 rows affected (0.00 sec)
 
mysql&gt; insert into runoob_transaction_test value(5);
Query OK, 1 rows affected (0.01 sec)
 
mysql&gt; insert into runoob_transaction_test value(6);
Query OK, 1 rows affected (0.00 sec)
 
mysql&gt; commit; # 提交事务
Query OK, 0 rows affected (0.01 sec)
 
mysql&gt;  select * from runoob_transaction_test;
+------+
| id   |
+------+
| 5    |
| 6    |
+------+
2 rows in set (0.01 sec)
 
mysql&gt; begin;    # 开始事务
Query OK, 0 rows affected (0.00 sec)
 
mysql&gt;  insert into runoob_transaction_test values(7);
Query OK, 1 rows affected (0.00 sec)
 
mysql&gt; rollback;   # 回滚
Query OK, 0 rows affected (0.00 sec)
 
mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入
+------+
| id   |
+------+
| 5    |
| 6    |
+------+
2 rows in set (0.01 sec)
</code></pre>
<h2 id="mysql-索引">MySQL 索引</h2>
<p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>
<p>例如：有一张person表，其中有2W条记录，记录着2W个人的信息。有一个Phone的字段记录每个人的电话号码，现在想要查询出电话号码为xxxx的人的信息。</p>
<p>如果没有索引，那么将从表中第一条记录一条条往下遍历，直到找到该条信息为止。</p>
<p>如果有了索引，那么会将 Phone 字段，通过一定的方法进行存储，好让查询该字段上的信息时，能够快速找到对应的数据，而不必在遍历2W条数据了。</p>
<h3 id="普通索引">普通索引</h3>
<h5 id="创建索引">创建索引</h5>
<p>最基本的索引，没有任何限制。</p>
<pre><code class="language-mysql">create INDEX indexName on table_name(column_name);
</code></pre>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<h5 id="修改表结构添加索引">修改表结构（添加索引）</h5>
<pre><code class="language-mysql">alter table teblename ADD indexname(column_name);
</code></pre>
<h5 id="创建表的时候直接指定">创建表的时候直接指定</h5>
<pre><code class="language-mysql">CREATE TABLE mytable(  
ID INT NOT NULL,   
username VARCHAR(16) NOT NULL,  
INDEX [indexName] (username(length))  
);  
</code></pre>
<h5 id="删除索引">删除索引</h5>
<pre><code class="language-mysql">drop index [indexName] on mytable;
</code></pre>
<h3 id="唯一索引">唯一索引</h3>
<p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<h5 id="创建索引-2">创建索引</h5>
<pre><code class="language-mysql">create unique index indeaname on mytable（username（length））
</code></pre>
<h5 id="修改表结构">修改表结构</h5>
<pre><code class="language-mysql">alter table mytable add unique [indexname] (username(length))
</code></pre>
<h5 id="创建表的时候指定">创建表的时候指定</h5>
<pre><code class="language-mysql">CREATE TABLE mytable(  
ID INT NOT NULL,   
username VARCHAR(16) NOT NULL,  
UNIQUE [indexName] (username(length))  
);  
</code></pre>
<h3 id="使用alter命令添加和删除索引">使用alter命令添加和删除索引</h3>
<p>有四种方式来添加数据表的索引：</p>
<ul>
<li><strong>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)</strong>:该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</li>
<li>**ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)😗*该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<h3 id="使用alter命令添加和删除主键">使用alter命令添加和删除主键</h3>
<p>主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。</p>
<pre><code class="language-mysql">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
</code></pre>
<p>使用alter命令删除主键：</p>
<pre><code class="language-mysql">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;
</code></pre>
<p>删除主键时只需要指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h3 id="显示索引信息">显示索引信息</h3>
<p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<pre><code class="language-mysql">mysql&gt; SHOW INDEX FROM table_name; \G
</code></pre>
<p>用EXPLAIN关键字，来查看索引是否正在被使用，并且输出其使用的索引信息</p>
<pre><code class="language-mysql">EXPLAIN SELECT * FROM book WHERE author = 'nana';
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 1.8 新特性]]></title>
        <id>https://QLZL.github.io/post/java-18-xin-te-xing/</id>
        <link href="https://QLZL.github.io/post/java-18-xin-te-xing/">
        </link>
        <updated>2020-10-31T04:24:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-lambda表达式">1、lambda表达式</h2>
<pre><code class="language-java">private static void dome1 () {
        //lambda表达式
        in i = (a, b) -&gt; a + b;
        int a = i.add(1,2);
        System.out.println(a);
}
</code></pre>
<h2 id="2-方法引用">2、方法引用</h2>
<pre><code class="language-java">private static void dome2 () {
    //方法引用
    Person[] persons = new Person[30];

    //原来写法
    class PersonAgeComparator implements Comparator&lt;Person&gt; {
        @Override
        public int compare(Person a, Person b) {
            return a.getAge().compareTo(b.getAge());
        }
    }
    Arrays.sort(persons, new PersonAgeComparator());

    //lambda表达式
    Arrays.sort(persons, (a, b) -&gt; 	            a.getAge().compareTo(b.getAge()));

    //调用Person中的静态比较器
    Arrays.sort(persons, (a, b) -&gt; Person.compareByAge(a, b));

    //方法引用写法
    Arrays.sort(persons, Person::compareByAge);

}
</code></pre>
<h2 id="3-函数式接口">3、函数式接口</h2>
<pre><code class="language-java">/**
 * 概念：函数式接口在java中是指:有且仅有一个抽象方法的接口。
 * 函数式接口，即适用于函数式编程场景的接口。
 * 而java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。
 * 只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。
 *
 * @FunctionalInterface
 * 一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。
 * 需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。(该接口是一个标记接口)
 */
private static void dome3 () {
    //函数式接口
    List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

    System.out.println(&quot;输出所有数据:&quot;);
    /**
         * Predicate &lt;T&gt; 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。
         * 该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。
         * 该接口用于测试对象是 true 或 false。
         */

    //原来写法
    Predicate&lt;Integer&gt; predicate2 = new Predicate&lt;Integer&gt;() {
        @Override
        public boolean test (Integer integer) {
            return true;
        }
    };
    //lambda表达式
    //        Predicate&lt;Integer&gt; predicate = n -&gt; true;
    //        eval(list, predicate);

    eval(list, n -&gt; true);
}
</code></pre>
<p>4、stream api</p>
<pre><code class="language-java">private static void demo4 () {
    /**
     * 在 Java 8 中, 集合接口有两个方法来生成流：
     *      stream() − 为集合创建串行流。
     *      parallelStream() − 为集合创建并行流。
     *
     * filter
     * filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：
     */
    System.out.print(&quot;strings:[&quot;);
    List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);
    strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()).forEach(i -&gt; System.out.print(i + &quot;,&quot;));
    System.out.println(&quot;]&quot;);
    /**
     * forEach
     * Stream 提供了新的方法 'forEach' 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：
     * limit
     * limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：
     */
    Random random1 = new Random();
    System.out.print(&quot;Random:[&quot;);
    random1.ints().limit(10).forEach(i -&gt; System.out.print(&quot;,&quot; + i));
    System.out.println(&quot;]&quot;);
    /**
     * map
     * map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：
     */
    List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
    // 获取对应的平方数
    System.out.print(&quot;numbers:[&quot;);
    numbers.stream().map(i -&gt; i*i).collect(Collectors.toList()).forEach(i -&gt; System.out.print(&quot;,&quot; + i));
    System.out.println(&quot;]&quot;);
    /**
     * sorted
     * sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：
     */
    Random random2 = new Random();
    System.out.print(&quot;Random:[&quot;);
    random2.ints(10, 100).limit(10).sorted().forEach(i -&gt; System.out.print(&quot;,&quot; + i));
    System.out.println(&quot;]&quot;);
}
</code></pre>
<h2 id="4-optional-类">4、Optional 类</h2>
<pre><code class="language-java">private static void demo5 () {
    /**
     * Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。
     * Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。
     * Optional 类的引入很好的解决空指针异常。
     *
     * 序号	方法 &amp; 描述
     * 1	static &lt;T&gt; Optional&lt;T&gt; empty()
     *      返回空的 Optional 实例。
     *
     * 2	boolean equals(Object obj)
     *      判断其他对象是否等于 Optional。
     *
     * 3	Optional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate)
     *      如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。
     *
     * 4	&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)
     *      如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional
     *
     * 5	T get()
     *      如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException
     *
     * 6	int hashCode()
     *      返回存在值的哈希码，如果值不存在 返回 0。
     *
     * 7	void ifPresent(Consumer&lt;? super T&gt; consumer)
     *      如果值存在则使用该值调用 consumer , 否则不做任何事情。
     *
     * 8	boolean isPresent()
     *      如果值存在则方法会返回true，否则返回 false。
     *
     * 9	&lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)
     *      如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。
     *
     * 10	static &lt;T&gt; Optional&lt;T&gt; of(T value)
     *      返回一个指定非null值的Optional。
     *
     * 11	static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)
     *      如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。
     *
     * 12	T orElse(T other)
     *      如果存在该值，返回值， 否则返回 other。
     *
     * 13	T orElseGet(Supplier&lt;? extends T&gt; other)
     *      如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。
     *
     * 14	&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)
     *      如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常
     *
     * 15	String toString()
     *      返回一个Optional的非空字符串，用来调试
     */
    String str = &quot;&quot;;
    Optional&lt;String&gt; optional = Optional.ofNullable(str);
    optional.orElse(&quot;123&quot;);
}
</code></pre>
<h2 id="5-日期时间-api">5、日期时间 API</h2>
<pre><code class="language-java">private static void demo6 () {
    /**
     * Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：
     *      Local(本地) − 简化了日期时间的处理，没有时区的问题。
     *      Zoned(时区) − 通过制定的时区处理日期时间。
     * 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。
     */
    // 获取当前的日期时间
    LocalDateTime currentTime = LocalDateTime.now();
    System.out.println(&quot;当前时间: &quot; + currentTime);

    LocalDate date1 = currentTime.toLocalDate();
    System.out.println(&quot;date1: &quot; + date1);

    Month month = currentTime.getMonth();
    int day = currentTime.getDayOfMonth();
    int seconds = currentTime.getSecond();

    System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);

    LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);
    System.out.println(&quot;date2: &quot; + date2);

    // 12 december 2014
    LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);
    System.out.println(&quot;date3: &quot; + date3);

    // 22 小时 15 分钟
    LocalTime date4 = LocalTime.of(22, 15);
    System.out.println(&quot;date4: &quot; + date4);

    // 解析字符串
    LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);
    System.out.println(&quot;date5: &quot; + date5);

    LocalDate date6 = LocalDate.parse(&quot;2000-12-12&quot;);
    System.out.println(&quot;date6: &quot; + date6);

    // 获取当前时间日期
    ZonedDateTime date7 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);
    System.out.println(&quot;date7: &quot; + date7);

    ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);
    System.out.println(&quot;ZoneId: &quot; + id);

    ZoneId currentZone = ZoneId.systemDefault();
    System.out.println(&quot;当期时区: &quot; + currentZone);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大数据开发需要掌握哪些知识？]]></title>
        <id>https://QLZL.github.io/post/da-shu-ju-kai-fa-xu-yao-zhang-wo-na-xie-zhi-shi/</id>
        <link href="https://QLZL.github.io/post/da-shu-ju-kai-fa-xu-yao-zhang-wo-na-xie-zhi-shi/">
        </link>
        <updated>2020-10-21T00:50:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-大数据里面的角色">一、大数据里面的角色</h2>
<h3 id="角色一大数据工程"><strong>角色一：大数据工程</strong></h3>
<p>大数据工程需要解决数据的定义、收集、计算与保存的工作，因此大数据工程师们在设计和部署这样的系统时首要考虑的是数据高可用的问题，即大数据工程系统需要实时地为下游业务系统或分析系统提供数据服务；</p>
<h3 id="角色二大数据分析"><strong>角色二：大数据分析</strong></h3>
<p>大数据分析角色定位于如何利用数据——即从大数据工程系统中接收到数据之后如何为企业或组织提供有产出的数据分析，并且确实能够帮助到公司进行业务改善或提升服务水平，所以对于大数据分析师来说，他们首要解决的问题是发现并利用数据的价值，具体可能包括：趋势分析、模型建立以及预测分析等。</p>
<h2 id="二-大数据工程师">二、大数据工程师</h2>
<p>针对角色一：大数据工程说，对应的工作岗位就叫大数据工程师，对于大数据工程师而言，您至少要掌握以下技能：</p>
<h3 id="linux基础"><strong>linux基础</strong></h3>
<p>因为大数据体系，基本都是开源软件，这些开源软件都是在开源的linux系统上运行的，所以你必须会基本的linux操作，比如用户管理，权限，shell编程之类的</p>
<h3 id="一门jvm系语言"><strong>一门JVM系语言</strong>：</h3>
<p>当前大数据生态JVM系语言类的比重极大，某种程度上说是垄断也不为过。这里我推荐大家学习Java或Scala，至于Clojure这样的语言上手不易，其实并不推荐大家使用。另外，如今是“母以子贵”的年代，某个大数据框架会带火它的编程语言的流行，比如Docker之于Go、Kafka之于Scala。</p>
<p>建议：学习Java或Scala</p>
<h3 id="计算处理框架"><strong>计算处理框架：</strong></h3>
<p>严格来说，这分为离线批处理和流式处理。流式处理是未来的趋势，建议大家一定要去学习；而离线批处理其实已经快过时了，它的分批处理思想无法处理无穷数据集，因此其适用范围日益缩小。事实上，Google已经在公司内部正式废弃了以MapReduce为代表的离线处理。</p>
<p>因此如果要学习大数据工程，掌握一门实时流式处理框架是必须的。当下主流的框架包括：Apache Samza, Apache Storm, Apache Spark Streaming以及最近一年风头正劲的Apache Flink。当然Apache Kafka也推出了它自己的流式处理框架：Kafka Streams</p>
<p>建议：学习Flink、Spark Streaming或Kafka Streams中的一个</p>
<h3 id="分布式存储框架"><strong>分布式存储框架：</strong></h3>
<p>虽说MapReduce有些过时了，但Hadoop的另一个基石HDFS依然坚挺，并且是开源社区最受欢迎的分布式存储，绝对您花时间去学习。当然开源世界中还有很多的分布式存储，国内阿里巴巴的OceanBase也是很优秀的一个。</p>
<p>建议：学习HDFS</p>
<h3 id="资源调度框架"><strong>资源调度框架：</strong></h3>
<p>Docker可是整整火了最近一两年。各个公司都在发力基于Docker的容器解决方案，最有名的开源容器调度框架就是K8S了，但同样著名的还有Hadoop的YARN和Apache Mesos。后两者不仅可以调度容器集群，还可以调度非容器集群，非常值得我们学习。</p>
<p>建议：学习YARN</p>
<h3 id="分布式协调框架"><strong>分布式协调框架：</strong></h3>
<p>有一些通用的功能在所有主流大数据分布式框架中都需要实现，比如服务发现、领导者选举、分布式锁、KV存储等。这些功能也就催生了分布式协调框架的发展。最古老也是最有名的当属Apache Zookeeper了，新一些的包括Consul，etcd等。学习大数据工程，分布式协调框架是不能不了解的， 某种程度上还要深入了解。</p>
<p>建议：学习Zookeeper——太多大数据框架都需要它了，比如Kafka, Storm, HBase等</p>
<h3 id="kv数据库"><strong>KV数据库：</strong></h3>
<p>典型的就是memcache和Redis了，特别是Redis简直是发展神速。其简洁的API设计和高性能的TPS日益得到广大用户的青睐。即使是不学习大数据，学学Redis都是大有裨益的。</p>
<p>建议：学习Redis，如果C语言功底好的，最好熟读源码，反正源码也不多</p>
<h3 id="列式存储数据库"><strong>列式存储数据库</strong>：</h3>
<p>人们针对行式存储不适用于大数据ad-hoc查询这种弊端开发出了列式存储，典型的列式存储数据库就是开源社区的HBASE。</p>
<p>建议：学习HBASE，这是目前应用最广泛的开源列式存储</p>
<h3 id="消息队列"><strong>消息队列：</strong></h3>
<p>大数据工程处理中消息队列作为“削峰填谷”的主力系统是必不可少的，当前该领域内的解决方案有很多，包括ActiveMQ，Kafka等。国内阿里也开源了RocketMQ。这其中的翘楚当属Apache Kafka了。Kafka的很多设计思想都特别契合分布流式数据处理的设计理念。这也难怪，Kafka的原作者Jay Kreps可是当今实时流式处理方面的顶级大神。</p>
<p>建议：学习Kafka，不仅仅好找工作(几乎所有大数据招聘简历都要求会Kafka:-） )，还能触类旁通进一步理解基于备份日志方式的数据处理范型</p>
<h2 id="三-大数据必备技能详细">三、大数据必备技能详细</h2>
<p>总共分为五大部分，分别是：</p>
<ul>
<li>大数据技术基础</li>
<li>离线计算Hadoop</li>
<li>流式计算Storm</li>
<li>内存计算Spark</li>
<li>机器学习算法</li>
</ul>
<h4 id="大数据技术基础">大数据技术基础</h4>
<h5 id="linux操作基础">linux操作基础</h5>
<ul>
<li>linux系统简介与安装</li>
<li>linux常用命令–文件操作</li>
<li>linux常用命令–用户管理与权限</li>
<li>linux常用命令–系统管理</li>
<li>linux常用命令–免密登陆配置与网络管理</li>
<li>linux上常用软件安装</li>
<li>linux本地yum源配置及yum软件安装</li>
<li>linux防火墙配置</li>
<li>linux高级文本处理命令cut、sed、awk</li>
<li>linux定时任务crontab</li>
</ul>
<h5 id="shell编程">shell编程</h5>
<ul>
<li>shell编程–基本语法</li>
<li>shell编程–流程控制</li>
<li>shell编程–函数</li>
<li>shell编程–综合案例–自动化部署脚本</li>
</ul>
<h5 id="内存数据库redis">内存数据库redis</h5>
<ul>
<li>redis和nosql简介</li>
<li>redis客户端连接</li>
<li>redis的string类型数据结构操作及应用-对象缓存</li>
<li>redis的list类型数据结构操作及应用案例-任务调度队列</li>
<li>redis的hash及set数据结构操作及应用案例-购物车</li>
<li>redis的sortedset数据结构操作及应用案例-排行榜</li>
</ul>
<h5 id="布式协调服务zookeeper">布式协调服务zookeeper</h5>
<ul>
<li>zookeeper简介及应用场景</li>
<li>zookeeper集群安装部署</li>
<li>zookeeper的数据节点与命令行操作</li>
<li>zookeeper的java客户端基本操作及事件监听</li>
<li>zookeeper核心机制及数据节点</li>
<li>zookeeper应用案例–分布式共享资源锁</li>
<li>zookeeper应用案例–服务器上下线动态感知</li>
<li>zookeeper的数据一致性原理及leader选举机制</li>
</ul>
<h5 id="java高级特性增强">java高级特性增强</h5>
<ul>
<li>Java多线程基本知识</li>
<li>Java同步关键词详解</li>
<li>java并发包线程池及在开源软件中的应用</li>
<li>Java并发包消息队里及在开源软件中的应用</li>
<li>Java JMS技术</li>
<li>Java动态代理反射</li>
</ul>
<h5 id="轻量级rpc框架开发">轻量级RPC框架开发</h5>
<ul>
<li>RPC原理学习</li>
<li>Nio原理学习</li>
<li>Netty常用API学习</li>
<li>轻量级RPC框架需求分析及原理分析</li>
<li>轻量级RPC框架开发</li>
</ul>
<h4 id="离线计算hadoop">离线计算Hadoop</h4>
<h5 id="hadoop快速入门">hadoop快速入门</h5>
<ul>
<li>hadoop背景介绍</li>
<li>分布式系统概述</li>
<li>离线数据分析流程介绍</li>
<li>集群搭建</li>
<li>集群使用初步</li>
</ul>
<h5 id="hdfs增强">HDFS增强</h5>
<ul>
<li>HDFS的概念和特性</li>
<li>HDFS的shell(命令行客户端)操作</li>
<li>HDFS的工作机制</li>
<li>NAMENODE的工作机制</li>
<li>java的api操作</li>
<li>案例1：开发shell采集脚本</li>
</ul>
<h5 id="mapreduce详解">MAPREDUCE详解</h5>
<ul>
<li>自定义hadoop的RPC框架</li>
<li>Mapreduce编程规范及示例编写</li>
<li>Mapreduce程序运行模式及debug方法</li>
<li>mapreduce程序运行模式的内在机理</li>
<li>mapreduce运算框架的主体工作流程</li>
<li>自定义对象的序列化方法</li>
<li>MapReduce编程案例</li>
</ul>
<h5 id="mapreduce增强">MAPREDUCE增强</h5>
<ul>
<li>Mapreduce排序</li>
<li>自定义partitioner</li>
<li>Mapreduce的combiner</li>
<li>mapreduce工作机制详解</li>
</ul>
<h5 id="mapreduce实战">MAPREDUCE实战</h5>
<ul>
<li>maptask并行度机制-文件切片</li>
<li>maptask并行度设置</li>
<li>倒排索引</li>
<li>共同好友</li>
</ul>
<h5 id="federation介绍和hive使用">federation介绍和hive使用</h5>
<ul>
<li>Hadoop的HA机制</li>
<li>HA集群的安装部署</li>
<li>集群运维测试之Datanode动态上下线</li>
<li>集群运维测试之Namenode状态切换管理</li>
<li>集群运维测试之数据块的balance</li>
<li>HA下HDFS-API变化</li>
<li>hive简介</li>
<li>hive架构</li>
<li>hive安装部署</li>
<li>hvie初使用</li>
</ul>
<h5 id="hive增强和flume介绍">hive增强和flume介绍</h5>
<ul>
<li>HQL-DDL基本语法</li>
<li>HQL-DML基本语法</li>
<li>HIVE的join</li>
<li>HIVE 参数配置</li>
<li>HIVE 自定义函数和Transform</li>
<li>HIVE 执行HQL的实例分析</li>
<li>HIVE最佳实践注意点</li>
<li>HIVE优化策略</li>
<li>HIVE实战案例</li>
<li>Flume介绍</li>
<li>Flume的安装部署</li>
<li>案例：采集目录到HDFS</li>
<li>案例：采集文件到HDFS</li>
</ul>
<h4 id="流式计算storm">流式计算Storm</h4>
<h5 id="storm从入门到精通">Storm从入门到精通</h5>
<ul>
<li>Storm是什么</li>
<li>Storm架构分析</li>
<li>Storm架构分析</li>
<li>Storm编程模型、Tuple源码、并发度分析</li>
<li>Storm WordCount案例及常用Api分析</li>
<li>Storm集群部署实战</li>
<li>Storm+Kafka+Redis业务指标计算</li>
<li>Storm源码下载编译</li>
<li>Strom集群启动及源码分析</li>
<li>Storm任务提交及源码分析</li>
<li>Storm数据发送流程分析</li>
<li>Storm通信机制分析</li>
<li>Storm消息容错机制及源码分析</li>
<li>Storm多stream项目分析</li>
<li>编写自己的流式任务执行框架</li>
</ul>
<h5 id="storm上下游及架构集成">Storm上下游及架构集成</h5>
<ul>
<li>消息队列是什么</li>
<li>Kakfa核心组件</li>
<li>Kafka集群部署实战及常用命令</li>
<li>Kafka配置文件梳理</li>
<li>Kakfa JavaApi学习</li>
<li>Kafka文件存储机制分析</li>
<li>Redis基础及单机环境部署</li>
<li>Redis数据结构及典型案例</li>
<li>Flume快速入门</li>
<li>Flume+Kafka+Storm+Redis整合</li>
</ul>
<h4 id="存计算spark">存计算Spark</h4>
<h5 id="scala编程">scala编程</h5>
<ul>
<li>scala编程介绍</li>
<li>scala相关软件安装</li>
<li>scala基础语法</li>
<li>scala方法和函数</li>
<li>scala函数式编程特点</li>
<li>scala数组和集合</li>
<li>scala编程练习（单机版WordCount）</li>
<li>scala面向对象</li>
<li>scala模式匹配</li>
<li>actor编程介绍</li>
<li>option和偏函数</li>
<li>实战：actor的并发WordCount</li>
<li>柯里化</li>
<li>隐式转换</li>
</ul>
<h5 id="akka与rpc">AKKA与RPC</h5>
<ul>
<li>Akka并发编程框架</li>
<li>实战：RPC编程实战</li>
</ul>
<h5 id="spark快速入门">Spark快速入门</h5>
<ul>
<li>spark介绍</li>
<li>spark环境搭建</li>
<li>RDD简介</li>
<li>RDD的转换和动作</li>
<li>实战：RDD综合练习</li>
<li>RDD高级算子</li>
<li>自定义Partitioner</li>
<li>实战：网站访问次数</li>
<li>广播变量</li>
<li>实战：根据IP计算归属地</li>
<li>自定义排序</li>
<li>利用JDBC RDD实现数据导入导出</li>
<li>WorldCount执行流程详解</li>
</ul>
<h5 id="rdd详解">RDD详解</h5>
<ul>
<li>RDD依赖关系</li>
<li>RDD缓存机制</li>
<li>RDD的Checkpoint检查点机制</li>
<li>Spark任务执行过程分析</li>
<li>RDD的Stage划分</li>
</ul>
<h5 id="spark-sql应用">Spark-Sql应用</h5>
<ul>
<li>Spark-SQL</li>
<li>Spark结合Hive</li>
<li>DataFrame</li>
<li>实战：Spark-SQL和DataFrame案例</li>
</ul>
<h5 id="sparkstreaming应用实战">SparkStreaming应用实战</h5>
<ul>
<li>Spark-Streaming简介</li>
<li>Spark-Streaming编程</li>
<li>实战：StageFulWordCount</li>
<li>Flume结合Spark Streaming</li>
<li>Kafka结合Spark Streaming</li>
<li>窗口函数</li>
<li>ELK技术栈介绍</li>
<li>ElasticSearch安装和使用</li>
<li>Storm架构分析</li>
<li>Storm编程模型、Tuple源码、并发度分析</li>
<li>Storm WordCount案例及常用Api分析</li>
</ul>
<h5 id="spark核心源码解析">Spark核心源码解析</h5>
<ul>
<li>Spark源码编译</li>
<li>Spark远程debug</li>
<li>Spark任务提交行流程源码分析</li>
<li>Spark通信流程源码分析</li>
<li>SparkContext创建过程源码分析</li>
<li>DriverActor和ClientActor通信过程源码分析</li>
<li>Worker启动Executor过程源码分析</li>
<li>Executor向DriverActor注册过程源码分析</li>
<li>Executor向Driver注册过程源码分析</li>
<li>DAGScheduler和TaskScheduler源码分析</li>
<li>Shuffle过程源码分析</li>
<li>Task执行过程源码分析</li>
</ul>
<h4 id="机器学习算法">机器学习算法</h4>
<h5 id="python及numpy库">python及numpy库</h5>
<ul>
<li>机器学习简介</li>
<li>机器学习与python</li>
<li>python语言–快速入门</li>
<li>python语言–数据类型详解</li>
<li>python语言–流程控制语句</li>
<li>python语言–函数使用</li>
<li>python语言–模块和包</li>
<li>phthon语言–面向对象</li>
<li>python机器学习算法库–numpy</li>
<li>机器学习必备数学知识–概率论</li>
</ul>
<h5 id="常用算法实现">常用算法实现</h5>
<ul>
<li>knn分类算法–算法原理</li>
<li>knn分类算法–代码实现</li>
<li>knn分类算法–手写字识别案例</li>
<li>lineage回归分类算法–算法原理</li>
<li>lineage回归分类算法–算法实现及demo</li>
<li>朴素贝叶斯分类算法–算法原理</li>
<li>朴素贝叶斯分类算法–算法实现</li>
<li>朴素贝叶斯分类算法–垃圾邮件识别应用案例</li>
<li>kmeans聚类算法–算法原理</li>
<li>kmeans聚类算法–算法实现</li>
<li>kmeans聚类算法–地理位置聚类应用</li>
<li>决策树分类算法–算法原理</li>
<li>决策树分类算法–算法实现</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot Data JPA]]></title>
        <id>https://QLZL.github.io/post/spring-boot-data-jpa/</id>
        <link href="https://QLZL.github.io/post/spring-boot-data-jpa/">
        </link>
        <updated>2020-09-21T04:17:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jpa是什么">JPA是什么？</h2>
<p>JPA(Java Persistence API)是Sun官方提出的Java持久化规范，为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。 它的出现是为了简化现有的持久化开发工作和整合ORM技术， 结束各个ORM框架各自为营的局面。</p>
<blockquote>
<p>JPA仅仅是一套规范,不是一套产品, 也就是说Hibernate, TopLink等是实现了JPA规范的一套产品.</p>
</blockquote>
<h2 id="spring-data-jpa">Spring Data JPA</h2>
<p>Spring Data JPA是Spring基于ORM框架、JPA规范的基础上封装的一套JPA应用框架,是基于Hibernate之上构建的JPA使用解决方案,用极简的代码实现了对数据库的访问和操作,包括了增、删、改、查等在内的常用功能.</p>
<h2 id="一-引入依赖">一、引入依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="二-添加配置">二、添加配置</h2>
<pre><code class="language-yml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/smile_boot?serverTimezone=UTC&amp;
    useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
    username: root
    password: root

  jpa:
    properties:
      hibernate:
        hbm2ddl:
          auto: create
        dialect: org.hibernate.dialect.MySQL5InnoDBDialect
        format_sql: true
    show-sql: true
</code></pre>
<p>hibernate.hbm2ddl.auto 参数的作用主要用于：自动创建、更新、验证数据库表结构，有四个值。</p>
<ol>
<li>
<p>create：每次加载 Hibernate 时都会删除上一次生成的表，然后根据 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</p>
</li>
<li>
<p>create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</p>
</li>
<li>
<p>update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</p>
</li>
<li>
<p>validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</p>
</li>
</ol>
<p>配置文件中</p>
<ol>
<li>
<p>dialect 主要是指定生成表名的存储引擎为 InnoDB</p>
</li>
<li>
<p>show-sql 是否在日志中打印出自动生成的 SQL，方便调试的时候查看</p>
</li>
</ol>
<h2 id="三-编写代码">三、编写代码</h2>
<pre><code class="language-java">@Entity
public class User {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false, unique = true)
    private String userName;

    @Column(nullable = false)
    private String passWord;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = true, unique = true)
    private String nickName;

    @Column(nullable = false)
    private String regTime;

    public User(String userName, String passWord, String email, String nickName, String regTime) {
        this.userName = userName;
        this.passWord = passWord;
        this.email = email;
        this.nickName = nickName;
        this.regTime = regTime;
    }

    public User() {
    }

    // getter and setter
}
</code></pre>
<p>注解：</p>
<ul>
<li>
<p>@Entity(name=&quot;EntityName&quot;) 必须，用来标注一个数据库对应的实体，数据库中创建的表名默认和类名一致。其中，name 为可选，对应数据库中一个表，使用此注解标记 Pojo 是一个 JPA 实体。</p>
</li>
<li>
<p>@Table(name=&quot;&quot;，catalog=&quot;&quot;，schema=&quot;&quot;) 可选，用来标注一个数据库对应的实体，数据库中创建的表名默认和类名一致。通常和 @Entity 配合使用，只能标注在实体的 class 定义处，表示实体对应的数据库表的信息。</p>
</li>
<li>
<p>@Id 必须，@Id 定义了映射到数据库表的主键的属性，一个实体只能有一个属性被映射为主键。</p>
</li>
<li>
<p>@GeneratedValue(strategy=GenerationType，generator=&quot;&quot;) 可选，strategy: 表示主键生成策略，有 AUTO、INDENTITY、SEQUENCE 和 TABLE 4 种，分别表示让 ORM 框架自动选择，generator: 表示主键生成器的名称。</p>
</li>
<li>
<p>@Column(name = &quot;user_code&quot;， nullable = false， length=32) 可选，@Column 描述了数据库表中该字段的详细定义，这对于根据 JPA 注解生成数据库表结构的工具。name: 表示数据库表中该字段的名称，默认情形属性名称一致；nullable: 表示该字段是否允许为 null，默认为 true；unique: 表示该字段是否是唯一标识，默认为 false；length: 表示该字段的大小，仅对 String 类型的字段有效。</p>
</li>
<li>
<p>@Transient可选，@Transient 表示该属性并非一个到数据库表的字段的映射，ORM 框架将忽略该属性。</p>
</li>
<li>
<p>@Enumerated 可选，使用枚举的时候，我们希望数据库中存储的是枚举对应的 String 类型，而不是枚举的索引值，需要在属性上面添加 @Enumerated(EnumType.STRING) 注解。</p>
</li>
</ul>
<h2 id="四-repository构建">四、Repository构建</h2>
<pre><code class="language-java">/**
 * JpaRepository&lt;T, ID&gt;的泛型
 *      T  实体类
 *      ID  主键的类型
 *
 * @RepositoryDefinition(domainClass = User.class, idClass = String.class)
 *      使用注解效果一致
 *
 */
public interface UserRepository extends JpaRepository&lt;User,Long&gt; {

    User findByUserNameOrEmail(String userName, String email);

    User findByUserName(String userName);

}
</code></pre>
<p>因为是继承,所以父类有的方法全部继承</p>
<h2 id="自定义查询">自定义查询</h2>
<p>Spring Data JPA 可以根据接口方法名来实现数据库操作，主要的语法是 findXXBy、readAXXBy、queryXXBy、countXXBy、getXXBy 后面跟属性名称，利用这个功能仅需要在定义的 Repository 中添加对应的方法名即可，使用时 Spring Boot 会自动帮我们实现.</p>
<pre><code class="language-java">//根据用户名查询用户：
User findByUserName(String userName);

//也可以加一些关键字 And、or：
User findByUserNameOrEmail(String username,String email);

//修改、删除、统计也是类似语法：
Long deleteById(Long id);
Long countByUserName(String userName);

//基本上 SQL 体系中的关键词都可以使用，如 LIKE 、IgnoreCase、OrderBy：
List&lt;User&gt; findByEmailLike(String email);
User findByUserNameIgnoreCase(String userName);
List&lt;User&gt; findByUserNameOrderByEmailDesc(String email);   
    
</code></pre>
<h3 id="关键字的使用和生产sql">关键字的使用和生产SQL:</h3>
<table>
<thead>
<tr>
<th>KeyWord</th>
<th>Sample</th>
<th>JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td>And</td>
<td>findByLastnameAndFirstname</td>
<td>… where x.lastname = ?1 and x.firstname = ?2</td>
</tr>
<tr>
<td>Or</td>
<td>findByLastnameOrFirstname</td>
<td>… where x.lastname = ?1 or x.firstname = ?2</td>
</tr>
<tr>
<td>Is，Equals</td>
<td>findByFirstnameIs，findByFirstnameEquals</td>
<td>… where x.firstname = ?1</td>
</tr>
<tr>
<td>Between</td>
<td>findByStartDateBetween</td>
<td>… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td>LessThan</td>
<td>findByAgeLessThan</td>
<td>… where x.age &lt; ?1</td>
</tr>
<tr>
<td>LessThanEqual</td>
<td>findByAgeLessThanEqual</td>
<td>… where x.age ⇐ ?1</td>
</tr>
<tr>
<td>GreaterThan</td>
<td>findByAgeGreaterThan</td>
<td>… where x.age &gt; ?1</td>
</tr>
<tr>
<td>GreaterThanEqual</td>
<td>findByAgeGreaterThanEqual</td>
<td>… where x.age &gt;= ?1</td>
</tr>
<tr>
<td>After</td>
<td>findByStartDateAfter</td>
<td>… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td>Before</td>
<td>findByStartDateBefore</td>
<td>… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td>IsNull</td>
<td>findByAgeIsNull</td>
<td>… where x.age is null</td>
</tr>
<tr>
<td>IsNotNull，NotNull</td>
<td>findByAge(Is)NotNull</td>
<td>… where x.age not null</td>
</tr>
<tr>
<td>Like</td>
<td>findByFirstnameLike</td>
<td>… where x.firstname like ?1</td>
</tr>
<tr>
<td>NotLike</td>
<td>findByFirstnameNotLike</td>
<td>… where x.firstname not like ?1</td>
</tr>
<tr>
<td>StartingWith</td>
<td>findByFirstnameStartingWith</td>
<td>… where x.firstname like ?1 (parameter bound with appended %)</td>
</tr>
<tr>
<td>EndingWith</td>
<td>findByFirstnameEndingWith</td>
<td>… where x.firstname like ?1 (parameter bound with prepended %)</td>
</tr>
<tr>
<td>Containing</td>
<td>findByFirstnameContaining</td>
<td>… where x.firstname like ?1 (parameter bound wrapped in %)</td>
</tr>
<tr>
<td>OrderBy</td>
<td>findByAgeOrderByLastnameDesc</td>
<td>… where x.age = ?1 order by x.lastname desc</td>
</tr>
<tr>
<td>Not</td>
<td>findByLastnameNot</td>
<td>… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td>In</td>
<td>findByAgeIn(Collection ages)</td>
<td>… where x.age in ?1</td>
</tr>
<tr>
<td>NotIn</td>
<td>findByAgeNotIn(Collection age)</td>
<td>… where x.age not in ?1</td>
</tr>
<tr>
<td>TRUE</td>
<td>findByActiveTrue()</td>
<td>… where x.active = true</td>
</tr>
<tr>
<td>FALSE</td>
<td>findByActiveFalse()</td>
<td>… where x.active = false</td>
</tr>
<tr>
<td>IgnoreCase</td>
<td>findByFirstnameIgnoreCase</td>
<td>… where UPPER(x.firstame) = UPPER(?1)</td>
</tr>
</tbody>
</table>
<h2 id="自定义sql查询">自定义SQL查询</h2>
<h3 id="在repository中增加方法">在Repository中增加方法:</h3>
<pre><code class="language-java">	/**
     * @Author Smith
     * @Description 自定义Sql查询.(这个本来是HQL的写法,我的运行不了,改成了本地的SQL)
     * @Date 10:18 2019/1/24
     * @Param 
     * @return org.springframework.data.domain.Page&lt;com.jpa.springdatajpa.model.User&gt;
     **/
    @Query(value = &quot;select * from user&quot;,nativeQuery = true)
    Page&lt;User&gt; findALL(Pageable pageable);

    /**
     * @Author Smith
     * @Description 原生SQL的写法,?1表示方法参数中的顺序
     * @Date 10:20 2019/1/24
     * @Param 
     * @return org.springframework.data.domain.Page&lt;com.jpa.springdatajpa.model.User&gt;
     **/
    @Query(value = &quot;select * from user where nick_name = ?1&quot;,nativeQuery = true)
    Page&lt;User&gt; findByNickName(String nickName, Pageable pageable);

    /**
     * @Author Smith
     * @Description 修改,添加事务的支持
     * @Date 10:21 2019/1/24
     * @Param 
     * @return int
     **/
    @Transactional(timeout = 10)
    @Modifying
    @Query(&quot;update User set userName = ?1 where id = ?2&quot;)
    int modifyById(String  userName, Long id);

    /**
     * @Author Smith
     * @Description 删除
     * @Date 10:22 2019/1/24
     * @Param 
     * @return void
     **/
    @Transactional
    @Modifying
    @Query(&quot;delete from User where id = ?1&quot;)
    @Override
    void deleteById(Long id);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习知识的5个阶段]]></title>
        <id>https://QLZL.github.io/post/xue-xi-zhi-shi-de-5-ge-jie-duan/</id>
        <link href="https://QLZL.github.io/post/xue-xi-zhi-shi-de-5-ge-jie-duan/">
        </link>
        <updated>2020-09-07T08:57:06.000Z</updated>
        <content type="html"><![CDATA[<p>1.收集（技术公众号、技术UP博主、GitHub、技术社区、书、视频等）</p>
<p>2.整理（写自己的知识总结）</p>
<p>3.复盘（回顾问题找出根本原因）</p>
<p>4.结构化（梳理知识，零散的知识点汇集起来整合起来，方便记忆理解）</p>
<p>5.知识输出（写技术博客，做项目把知识高效沉淀下来）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java工程师学习路线]]></title>
        <id>https://QLZL.github.io/post/java-gong-cheng-shi-xue-xi-lu-xian/</id>
        <link href="https://QLZL.github.io/post/java-gong-cheng-shi-xue-xi-lu-xian/">
        </link>
        <updated>2020-09-07T08:44:02.000Z</updated>
        <content type="html"><![CDATA[<p>1.java基础<br>
2.spring全家桶<br>
3.redis<br>
4.消息队列<br>
5.数据库<br>
6.jvm<br>
7.分布式<br>
8.算法和数据结构<br>
9.系统架构设计</p>
<blockquote>
<p><strong>毕业西电Java工作3年拿到了30Koffer</strong></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spirng Boot 学习]]></title>
        <id>https://QLZL.github.io/post/spirng-boot-xue-xi/</id>
        <link href="https://QLZL.github.io/post/spirng-boot-xue-xi/">
        </link>
        <updated>2020-09-07T07:05:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-component和configurationproperties">一、@Component和@ConfigurationProperties</h2>
<p>在entity类（POJO类）中，使用@ConfigurationProperties注解，需要加上@Component。@ConfigurationProperties的作用和@Value一样；@ConfigurationProperties的属性prefix是指定配置文件中，对应属性的前缀名。</p>
<p>@ConfigurationProperties可以作用到类上，也可以作用到方法上。在作用到方法上，需要加上@Bean注解。</p>
<h2 id="二-value">二、@Value</h2>
<p>@Value：Spring底层注解，作用在属性上，其作用和Spring配置文件中，<bean></bean>的方式是一样的。</p>
<p>@Value  字面量、#{}（支持SpringEL表达式）、${key}（从环境变量、配置文件中获取值）</p>
<h2 id="jsr303数据校验">JSR303数据校验</h2>
<p>@Validated  加入数据校验</p>
<p>只支持@ConfigurationProperties</p>
<table>
<thead>
<tr>
<th>限制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>限制只能为null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>限制必须不为null</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>限制必须为false</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>限制必须为true</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td>@Digits(integer,fraction)</td>
<td>限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction</td>
</tr>
<tr>
<td>@Future</td>
<td>限制必须是一个将来的日期</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td>@Past</td>
<td>限制必须是一个过去的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>限制必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>限制字符长度必须在min到max之间</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格</td>
</tr>
<tr>
<td>@Email</td>
<td>验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式</td>
</tr>
</tbody>
</table>
<p>需要的依赖</p>
<pre><code class="language-xml">		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://QLZL.github.io/post/hello-gridea/</id>
        <link href="https://QLZL.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>